##########
#
# Author: Samuel Rosin
# Date: May 7, 2020
#
# The following three functions culminate in calc_estimands(), which
# is used to return 
# mu(100,0,alpha) and mu(100,1,alpha)
# for several given values of alpha. 
#
# Much of this code is based on 
#     Bradley Saul's interferenceSim package:
#        https://github.com/bsaul/interferenceSim
##########

#-----------------------------------------------------------------------------#
#' Individual level causal estimand mu_ij(t, a, alpha)
#' 
#' Takes n X n  x 2 array as input
#' @return n x 2 matrix with values of f-bar_ij(t, a, alpha) 
#' 
#-----------------------------------------------------------------------------#
fbar_i_aalpha <- function(outcomes, alpha, time.until=100){
  
  ## Necessary bits ##
  nn <- dim(outcomes)[1]
  kk <- 0:(nn - 1)
  aa <- alpha
  
  ## Create array for output ##
  out <- array(dim = c(nn, 2), dimnames = list(id = dimnames(outcomes)$id,
                                               trt = dimnames(outcomes)$trt))
  
  fbar <- function(po.times, alpha, time.until=100){
    ind <- ifelse(po.times < time.until, 1, 0)
    return(sum(ind * choose(nn - 1, kk) * aa^(kk) * (1 - aa)^(nn - kk - 1)))
  }
  out[ , 1] <- apply(outcomes[ , , 1], 1, fbar) 
  out[ , 2] <- apply(outcomes[ , , 2], 1, fbar)
  
  return(out)
}

#-----------------------------------------------------------------------------#
#' Individual level marginal causal estimand f-bar(t, alpha)
#' Takes the n x 2 matrix returned by fbar_ij_aalpha
#' 
#' @return n x 1 vector of fbar_ij(alpha) 
#-----------------------------------------------------------------------------#
fbar_i_alpha <- function(input, alpha){
  alpha*input[, 2] + (1 - alpha) * input[, 1]
}

#-----------------------------------------------------------------------------#
#' Calculate estimands
#' 
#' Takes a set of potential outcomes generated by \code{\link{sim_dataset}} and 
#' returns a data frame containing the population level causal estimands
#' 
#' @param potential_outcomes a list of potential outcomes generated by 
#' \code{\link{generate_po}}
#' @param alphas a vector of 'allocation schemes' in (0, 1)
#' @param time.until t, where the estimand is defined in terms of the contrast 
#' in the risk of having an event by time t. Currently defined for a single value. 
#' @return a data frame with 4 columns: 1) alpha (the allocation scheme) 2)
#' a0 - the outcome estimand for untreated, 3) a1 - the outcome estimand for
#' treated, 4) marg - the marginal outcome estimand
#' @examples 
#' calc_estimands(sim_dataset()[[2]], seq(.2, .8, by = .1), time.until = 100)
#' @export
#-----------------------------------------------------------------------------#

calc_estimands <- function(potential_outcomes, alphas, time.until = 100){
  
  ## Calculate population level outcomes based on 
  ## individual --> group --> population
  estimands <- function(alpha, potential_outcomes){
    
    # --- Individual average potential outcomes --- #  
    ind_avg_po <- lapply(potential_outcomes, function(x) fbar_i_aalpha(x, alpha, time.until))
    
    # --- Group average potential outcomes --- #                
    grp_avg_po <- lapply(ind_avg_po, function(x) apply(x, 2, mean))
    grp_avg_po <- matrix(unlist(grp_avg_po), ncol=2, byrow = T)
    # --- Population average potential outcomes --- # 
    pop_avg_po <- apply(grp_avg_po, 2, mean)
    
    # --- Marginal potential outcomes --- #
    ind_marg_po <- lapply(ind_avg_po, function(x) fbar_i_alpha(x, alpha))
    grp_marg_po <- unlist(lapply(ind_marg_po, mean))
    pop_marg_po <- mean(grp_marg_po)
    
    return(data.frame(alpha = alpha, 
                      mu0    = pop_avg_po[1],
                      mu1    = pop_avg_po[2],
                      mu.marg  = pop_marg_po))
  }
  
  ## Apply the above function to each alpha level ##
  true_effects <- lapply(alphas, estimands, 
                         potential_outcomes = potential_outcomes)
  
  truth <- do.call(rbind, true_effects)
  return(truth)
}